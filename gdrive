#!/usr/bin/env python3

"""A script to interact with your Google Drive files using the terminal"""

import pickle
import glob
import os.path
import io
import sys
import mimetypes
import threading
import time
import getopt
from os.path import expanduser
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from googleapiclient.errors import HttpError

UPLOAD_CHUNK_SIZE = 1024 * 1024 * 128 # 128MB
DOWNLOAD_CHUNK_SIZE = 1024 * 1024 * 128 # 128MB

HOME = expanduser("~")
GDRIVE_PATH = HOME + '/.gdrive/'
CREDENTIALS_PATH = GDRIVE_PATH + 'credentials.json'
TOKEN_PATH = GDRIVE_PATH + 'token.pickle'

# If modifying these scopes, delete the file token.pickle.
SCOPES = [
    'https://www.googleapis.com/auth/drive',
    'https://www.googleapis.com/auth/drive.metadata'
]

functions = ['download', 'upload', 'list']

def init():
    """Shows basic usage of the Drive v3 API.
    Prints the names and ids of the first 10 files the user has access to.
    """
    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists(TOKEN_PATH):
        with open(TOKEN_PATH, 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                CREDENTIALS_PATH, SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)
    service = build('drive', 'v3', credentials=creds)
    return service

def get_metadata(service, file_id):
    """Gets the file name for a file ID"""
    try:
        fields = 'id, name, size, modifiedTime, modifiedByMeTime, owners'
        return service.files().get(fileId=file_id, fields=fields).execute()
    except HttpError:
        return None

def size_to_human_readable(num, suffix='B'):
    """Converts bytes to a more human-readable metric"""
    for unit in ['', 'K', 'M', 'G', 'T']:
        if abs(num) < 1024.0:
            return "%3.1f%s%s" % (num, unit, suffix)
        num /= 1024.0
    return None

def search_filename(service, filename=None, page_size=10, list_all=False, page_token=None):
    """Search for a file by filename in the Google Drive"""
    query = ''
    if filename and not list_all:
        # Could also be name = '%s' for an exact search
        query = "name contains '%s'" % filename
    if page_token is None:
        page_token = ''
    fields = ('nextPageToken, files/id, files/name, files/size, '
              'files/modifiedTime, files/modifiedByMeTime, files/owners')
    search = service.files().list(q=query,
                                  orderBy='modifiedByMeTime desc',
                                  fields=fields,
                                  pageSize=page_size,
                                  pageToken=page_token).execute()
    return search.get('files', []), search.get('nextPageToken', None)

def list_files(service, filename, list_all=False):
    """List files present on user's Google Drive"""
    files_found, next_page = search_filename(service, filename, 10, list_all)
    for metadata in files_found:
        describe_file(metadata)
    while next_page is not None:
        if input(">>> Press Enter for the next results\n"):
            break
        files_found, next_page = search_filename(service, filename, 10, list_all, next_page)
        for metadata in files_found:
            describe_file(metadata)

def describe_file(metadata):
    """Print file metadata"""
    print("Name: %s" % metadata["name"])
    print("Owner: %s" % metadata["owners"][0]["displayName"])
    if 'size' in metadata:
        print("Size: %s" % size_to_human_readable(float(metadata["size"])))
    if 'modifiedByMeTime' in metadata:
        print("Modified by Me: %s" % metadata["modifiedByMeTime"])
    else:
        print("Modified: %s" % metadata["modifiedTime"])
    print("ID: %s\n" % metadata["id"])

def download_last(service):
    """Get the last modified file and download it"""
    files_found, _ = search_filename(service, None, 1, True)    
    if not files_found:
        print("Could not find any file")
        return None
    return download(service, files_found[0]["id"], files_found[0])

def download_search(service, filename):
    """Search for a file and download it"""
    if filename:
        files_found, _ = search_filename(service, filename, 1)
    else:
        print('Please inform the name of the file you want to download. Exiting...')
        return None
    if not files_found:
        print("Could not find any file that contains '%s' on the name" % filename)
        return None
    return download(service, files_found[0]["id"], files_found[0])

def download(service, file_id, metadata=None):
    """Download a file by file ID"""
    if file_id is None:
        print('Please inform the ID of the file you want to download. Exiting...')
        return

    if metadata is None:
        metadata = get_metadata(service, file_id)
        if not metadata:
            print('Could not find file with that File ID')
            return
    filename = metadata["name"] or "gdrive-file1"
    describe_file(metadata)

    try:
        request = service.files().get_media(fileId=file_id)

        file_handler = io.FileIO(filename, 'wb')
        downloader = MediaIoBaseDownload(file_handler, request, chunksize=DOWNLOAD_CHUNK_SIZE)

        done = False
        print("Downloading 0%", end='\r')
        logger = Logger("Downloading")
        while done is False:
            status, done = downloader.next_chunk()
            logger.send(status)
        logger.close()
        print("Downloaded 100% ")
    except Exception as err:
        print('An error happened while downloading the file.')
        print(err)

def upload_last_modified(service, filename):
    """Search a file with wildcard support, sorting by last modified"""
    files_found = glob.glob(filename)
    files_found.sort(key=os.path.getmtime, reverse=True)
    if len(files_found) == 0:
        print('Could not find any files with "%s"' % filename)
        return
    chosen_file = files_found[0]
    print('Found %s files, uploading last modified file: %s' % (len(files_found), chosen_file))
    upload(service, str(chosen_file))

def upload(service, filepath):
    """Upload a file"""
    guessed_type = mimetypes.guess_type(filepath, True)
    if guessed_type is None:
        print('Wasn`t able to guess mimetype.')
        return
    mime_type = guessed_type[0]

    filename = filepath.split('/')[-1]
    print('Uploading the file: %s' % filename)

    try:
        file_metadata = {'name': filename}
        media = MediaFileUpload(filepath,
                                mimetype=mime_type,
                                resumable=True,
                                chunksize=UPLOAD_CHUNK_SIZE)
        created_file = service.files().create(body=file_metadata,
                                              media_body=media,
                                              fields='id')
        response = None
        print("Uploading 0%", end='\r')
        logger = Logger("Uploading")
        while response is None:
            status, response = created_file.next_chunk()
            if status:
                logger.send(status)
        logger.close()
        print("Uploaded 100% ")
        print('File ID: %s\n' % response.get('id'))
    except Exception as err:
        print('An error occurred while uploading the file.')
        print(err)

def read_argv():
    """Read arguments"""
    file_id = filename = list_all = last_modified = None
    try:
        opts, _ = getopt.getopt(sys.argv[2:], "haln:i::", ["help", "all", "last", "name=", "id="])
    except getopt.GetoptError:
        print_help()
    for opt, value in opts:
        if opt in ("-h", "--help"):
            print_help()
        if opt in ("-a", "--all"):
            list_all = True
        elif opt in ("-l", "--last"):
            last_modified = True
        elif opt in ("-i", "--id"):
            file_id = value
        elif opt in ("-n", "--name"):
            filename = value
        else:
            assert False, "unhandled option"
    return {'file_id': file_id,
            'filename': filename,
            'list_all': list_all,
            'last_modified': last_modified}

def print_help():
    """Print help"""
    print("Download examples:")
    print("\tdownload --last")
    print("\tdownload -l")
    print("\tdownload some_file.gz")
    print("\tdownload *file*")
    print("\tdownload fileid123456")
    print("\tdownload --name some_file.gz")
    print("\tdownload -n some_file.gz")
    print("\tdownload --id fileid123456")
    print("\tdownload -i fileid123456")
    print("\nUpload examples:")
    print("\tupload some_file.gz")
    print("\tupload --last *file*")
    print("\tupload -l *file*")
    print("\nList examples:")
    print("\tlist some_file")
    print("\tlist --all")
    print("\tlist -a")
    sys.exit()

def main():
    """Main function. Entry point for the script"""
    args_size = len(sys.argv)
    if args_size < 3:
        print_help()
        return

    func = sys.argv[1]
    if func not in functions:
        print('This function is not implemented yet.')
        print_help()
        return

    service = init()
    if service is None:
        print('Failed to start service. Exiting...')
        return

    opt = read_argv()
    if func == 'download':
        # Downloads with the given file ID
        if opt['file_id']:
            download(service, opt['file_id'])
        elif opt['last_modified']:
            download_last(service)
        elif opt['filename']:
            download_search(service, opt['filename'])
        else:
            # Tries to download with the argument as an ID
            metadata = get_metadata(service, sys.argv[2])
            if metadata:
                download(service, sys.argv[2], metadata)
            # If that fails, tries to use it as a name
            else:
                download_search(service, sys.argv[2])
    if func == 'upload':
        if opt['last_modified']:
            upload_last_modified(service, sys.argv[3])
        else:
            upload(service, sys.argv[2])
    if func == 'list':
        list_files(service, sys.argv[2], opt['list_all'])


class ConflatedChannel:
    """A list of size 0 or 1. When adding to a list of size=1, substitute the value"""
    def __init__(self):
        """Initialize channel"""
        self.__channel = []
        self.__open = True

    def __str__(self):
        """String representation"""
        return str(self.__channel)

    def send(self, value):
        """Adds to the channel. If full, replace value.
        If channel is closed, raise a ValueError.
        """
        if not self.is_open():
            raise ValueError("Channel is closed.")

        self.__channel.clear()
        self.__channel.append(value)

    def pop(self):
        """Returns the value in the channel, or None"""
        try:
            return self.__channel.pop()
        except:
            return None

    def is_open(self):
        """Checks if the channel is open for send()"""
        return self.__open

    def close(self):
        """Close the channel. It will not receive new values."""
        self.__open = False

class Logger():
    """Logs progress from a worker thread."""
    def __init__(self, operation):
        self.__channel = ConflatedChannel()
        self.__operation = operation
        self.__start_time = time.time()
        self.__worker = threading.Thread(target=self.__work, daemon=True)
        self.__worker.start()

    def send(self, status):
        """Try to send a new value to the channel."""
        self.__channel.send(status)

    def close(self):
        """Close the channel and join the thread."""
        self.__channel.close()
        self.__worker.join()

    def __work(self):
        """Print logs while the channel is open and receiving values."""
        last_size = 0.0
        last_time = self.__start_time
        while self.__channel.is_open():
            status = self.__channel.pop()
            if status:
                new_time = time.time()
                self.__log_progress(status, last_size, last_time)
                last_time = new_time
                last_size = status.resumable_progress
            # Limits logs to 1 per second at most
            time.sleep(1)

    def __log_progress(self, status, previous_size, previous_time):
        """Print log from status."""
        progress = int(status.progress() * 100)
        total_size = size_to_human_readable(status.total_size)
        current_size = status.resumable_progress
        size = size_to_human_readable(current_size)

        current_time = time.time()
        timer = time.strftime("%H:%M:%S", time.gmtime(current_time - self.__start_time))

        diff_size = current_size - previous_size
        diff_time = current_time - previous_time
        speed = size_to_human_readable(diff_size / diff_time)

        estimated_time = (status.total_size - current_size) / diff_size / diff_time
        eta = time.strftime("%H:%M:%S", time.gmtime(estimated_time))

        print("%s %d%% - %s/%s - %s/s - %s - ETA: %s             " %
              (self.__operation, progress, size, total_size, speed, timer, eta), end='\r')

if __name__ == '__main__':
    main()
